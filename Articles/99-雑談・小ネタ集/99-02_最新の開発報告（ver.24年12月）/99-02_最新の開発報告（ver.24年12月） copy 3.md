前の記事　[「00-02_自作の「レベル」とは」](https://github.com/shinrabansyo/tech-blog/tree/main/Articles/99-%E9%9B%91%E8%AB%87%E3%83%BB%E5%B0%8F%E3%83%8D%E3%82%BF%E9%9B%86/99-01_%E6%A3%AE%E7%BE%85%E4%B8%87%E8%B1%A1%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%8C%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%BE%E3%81%A7%E3%80%81%E3%80%81%E3%80%82)  




# 1.近況報告_Astalisks編

(担当: xxxx) 

あああ  
  

# 2.近況報告_Koonato編

(担当: xxxx) 

あああ


# 3.近況報告_wakuto編

(担当: xxxx) 

あああ  


# 4.近況報告_yn0014編

(担当: yn0014) 

森羅万象プロジェクトではコンピュータに関わるものを全て自作しています
Astalisksさんやkoonatoさん，wakutoさんの節でも既に触れられていますが，CPUやアセンブリはもちろん，命令セットのレベルから全て自作しています．

さて，全て自作な環境でプログラムを動かすときの一番の壁は何でしょうか？
それはデバッグ工程です．
このプロジェクトでは命令セットから何まで全て独自仕様であるため，書いたプログラムをとりあえず動かしてみるということが簡単に出来ません．
プロジェクトの最大の強みが一転，デバッグ工程では最大の弱みとなってしまいます．

実はこれまで森羅万象プロジェクトでは，手書きしたアセンブリを眺める（脳内実行する）ことでのみデバッグを行っていました．
...なんと結成から1年半以上脳内実行に頼っていました．
というよりかは，メンバーの力で1年半は脳内実行で耐えることができていたので，その必要性があまり感じられていませんでした．

しかし，SDカード制御プログラムのデバッグにて「無理そう！」となり...2024年11月，デバッガの開発に着手しました．
本節ではそのデバッガについて説明します．

## デバッガ

森羅万象プロジェクトデバッガ（以下，デバッガ）はプロジェクト独自の命令セットに対応したデバッガです．
デバッガはアセンブラが出力した命令列を入力として，その命令列の実行過程をTUI上で観察することができます．
（注: 実際にはほぼエミュレータですが，今後の発展を願ってデバッガと呼んでいます...！）

### 実行

実際にデバッガを使用している様子を見てみましょう．
ここでは"Hello World!"の出力を行うプログラムを作成しアセンブル，そしてデバッガで実行する様子を追っていきます．

まず，"Hello World!"の出力を行うプログラム（アセンブリ）を作成します．
ざっと次のようになります．
（余談: ちょっとだけ形式が独特ですが，既存のものより読みやすくないですか？？）

```asm
// データメモリ

$helloworld
    string "Hello world!"

===

// 命令メモリ

@func_main
    // フレームポインタの設定
    addi r2 = r0, 0x100

    // "Hello world!"
    addi r10 = r0, $helloworld
    beq r1, (r0, r0) -> @func_print

    // 無限ループ
    @loop.func_main
        beq r0, (r0, r0) -> @loop.func_main

@func_print
    // フレームポインタの退避
    subi r2 = r2, 4
    sw r2[0] = r3
    addi r3 = r2, 0

    // レジスタの退避
    subi r2 = r2, 4
    sw r3[-4] = r1

    // 文字列出力ループ
    add r4 = r0, r10
    @loop.func_print
        // 文字列取得
        lb r5 = r4[0]

        // NULLチェック
        beq r0, (r5, r0) -> @end.loop.func_print

        // 出力
        out r0[0] = r5

        // カウンタ加算
        addi r4 = r4, 1
        beq r0, (r0, r0) -> @loop.func_print
    @end.loop.func_print

    // 改行文字出力
    addi r4 = r0, 10
    out r0[0] = r4

    // レジスタの復元
    lw r1 = r3[-4]
    addi r2 = r2, 4

    // フレームポインタの復元
    lw r3 = r3[0]
    addi r2 = r2, 4

    // return
    jal r0, r1[0]
```

次にこのプログラムをアセンブルします．
（注: 森羅万象プロジェクトのCPUはハーバードアーキテクチャを採用しているため，データメモリ，命令メモリ用のファイルがそれぞれ分けて出力されます．）

```bash
$ cd assembler
$ cargo run helloworld.asm imem.txt dmem.txt
$ ls
... imem.txt dmem.txt
```

そしてデバッガを起動します．
デバッガの起動オプションとして，アセンブルした結果出力されたファイルをそれぞれ指定します．
（注: imem.hex，dmem.hexは適切に移動している前提です）

```bash
$ cd debugger
$ cargo run -- --inst=imem.hex --data=dmem.hex
```

![実行の様子](images/debugger.gif)

実行できました！
画面左下にUARTデバイスの状態が表示されていますが，"Hello World!"が出力されていることが確認できます．

### 機能

デバッガには次の4機能があります．

1. 実行中の命令の表示
2. デバイス状態の表示
3. レジスタの表示
4. メモリの表示

各機能はそれぞれ，TUI上に次のように配置されています．
それぞれの四角はウィンドウを表しており，枠が太くなっているウィンドウはそれがアクティブであることを示しています．
ユーザは，`h` `j` `k` `l` キーでアクティブなウィンドウを切り替えることができます．
アクティブなウィンドウに対してキー入力を行うことで，そのウィンドウに対する操作を行うことができます．

![配置](images/debugger_mapping.png)

#### 実行中の命令の表示

画面左上のウィンドウには実行中の命令（とその周辺にある命令）が表示されます．
このウィンドウがアクティブであるとき，矢印キーを押すことで表示する命令の位置を変更することができます．

#### デバイス状態の表示

画面右上のウィンドウにはデバイスの状態が表示されます．
このウィンドウがアクティブであるとき，矢印キーを押すことで表示するデバイスを変更することができます．
現在，次の2つのデバイスが実装済みです．

1. UART
2. GPIO

#### レジスタの表示

画面左下のウィンドウにはレジスタの値が表示されます．
このウィンドウに対する操作は現在のところ実装していません．
（余談: 何か良い感じの操作がないかな～と思っています．2進や16進の切り替えとか？）

#### メモリの表示

画面右下のウィンドウにはメモリの値が表示されます．
このウィンドウがアクティブであるとき，矢印キーを押すことで表示するメモリの位置を変更することができます．

### 開発

デバッガの開発はRustを用いて行っています．
また，TUIライブラリとして`ratatui`を使用しています．
詳細な実装は記事の範囲を超えるため省略しますが，1つだけ感想を話すなら「`ratatui`めっちゃ使いやすい～～」です．
実際のコードはGitHubリポジトリを参照してみてください...！

[GitHubリポジトリ](https://github.com/shinrabansyo/debugger)

### 実際どうだった？

実のところ，SDカードをデバイスとしてエミュレート出来ていないため，SDカード制御プログラムのデバッグの大部分はまだ実機上で行う必要があります...．
一方で，いわゆるユーティリティ関数のデバッグにはデバッガを活用することができました．
例えば，GPIOを制御する関数内で実行しているビット操作の誤りをデバッガを用いて発見し，修正することができました．
今後は，プログラムのロジックバグの修正にはデバッガを，CPU本体や周辺回路のデバッグにはRTLシミュレータを，その他のどうしようもない部分は実機でデバッグするという使い分けを行っていく予定です．
（裏話: 実はコンパイラの開発に着手していたりしますが，これはまだ不完全なのでまた別の機会で...！）
