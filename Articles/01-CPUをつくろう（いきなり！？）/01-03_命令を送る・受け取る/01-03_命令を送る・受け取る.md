こんにちは！森羅万象プロジェクトです！
前回は[01-02_加算器をつくり](https://github.com/shinrabansyo/tech-blog/blob/main/Articles/01-CPU%E3%82%92%E3%81%A4%E3%81%8F%E3%82%8D%E3%81%86%EF%BC%88%E3%81%84%E3%81%8D%E3%81%AA%E3%82%8A%EF%BC%81%EF%BC%9F%EF%BC%89/01-02_%E5%8A%A0%E7%AE%97%E5%99%A8%E3%82%92%E3%81%A4%E3%81%8F%E3%82%8B/01-02_%E5%8A%A0%E7%AE%97%E5%99%A8%E3%82%92%E3%81%A4%E3%81%8F%E3%82%8B.md)ました。  
  
今回は**足し算ができ、他の命令もわかるようにするCPU（の一部）**を作っていきたいと思います。  
  
（定期宣伝）  
ちなみにこの記事は、   
**CPUを作ったことのなかった人による、**  
**CPUを作ったことのない人のための記事**  
ですので、CPU入門・初心者の筆者と一緒に勉強していただけたらと思っています！！  
  
  
今回は、「算術論理ユニット（Arithmetic and Logic Unit）」について、  
**1.ALUができたら足し算以外も「分かる」らしい、、**  
**2.命令を「分かる」ために必要な要素とは？**  
**3.そもそも、電気だけで命令をどう作っている？**  
**4.ALUをChiselでつくってみた！**
に分けて説明していきます。

# 1.ALUができたら足し算以外も「分かる」らしい、、  
・前回の記事では、CPUの機能の一部に  
  
1. **演算処理ユニット（Arithmetic Logic Unit, ALU）**  
   - 数値演算: 加算、減算、乗算、除算などの基本的な算術演算を実行。  
   - 論理演算: AND、OR、NOT、XORなどのビット単位の論理演算を行う。  
   （これらは全部NANDを組み合わせるだけでできる。NAND最強。）
  
っていう部分があり、ALUを作っているんだぞぉ。と言った気がします。（すみません。筆者引っ越したりしたので  
1ヶ月ほど経っていましてあんまり覚えてない、、。）  
しかし、足し算「だけ」できるCPUよりは、足し算「も」できるCPUを作りたいですよね。  
加算器でええやん、CPUちゃうやん、って言われてしまいそうですし、、。  
既に「こんなことやってます！」って[取り組みを発表したりしてます](https://www.security-camp.or.jp/event/awardreport.html)し、、。  
（おっ、宣伝チャンスか？）  
[セキュリティキャンプ](https://www.security-camp.or.jp/index.html)に参加し、  
グループワークの活動や個人の活動を続けると、3月に行われるセキュリティキャンプフォーラムで発表の機会があり、  
人脈形成、キャリア形成にとっても有効なので、是非参加してみてください！！  
ちなみにフォーラムはキャンプ参加者でなくとも参加できますし、発表以外にもためになる講演やトークショーもあるので、  
募集要項を確認してみてください！！  
（あっ、そろそろ本題に戻りますね）  
というわけで、今回は足し算「も」できるALUを作っていきますね！！  
  
  
# 2.命令を「分かる」ために必要な要素とは？  
CPUを作るにあたって、命令を「分かる」ために必要な要素を考えてみましょう。  
  
・まず、「足し算をする」という命令と（ひとまず例として）「引き算をする」という命令を見分けるには、  
足し算を命令A, 引き算を命令Bとしておけばよさそうでしょうか。  
（ついでにCPUっぽく、命令001と命令010（２進数）にしておきましょうか。）  
  
・足し算引き算だけじゃなく、プログラムを少し勉強するとif文みたいなのが出てきますよね。  
「加算減算でない別種の命令」が必要という感じでしょうか。  
（if文みたいなのをA-1,足し算をB-1,引き算を（引き算は足し算と似てる感じなので）B-2として、  
これもCPUっぽく、001-001、010-001、010-010という風に書いておきますか。）  
  
・命令を出すとなったら、出した命令の順番を覚えておきたくなりませんか？  
なりますよね？そう、なるんですよ（ゴリ押し、でもなるでしょ？）。  
じゃあ、順番・時系列を「カウント」しておくものが必要になります。  
（１回目が足し算、３回目が引き算なら、01:010-001、11:010-010、みたいな感じ。）  
  
・そういえば、足し算や引き算をしたら、結果を保存する必要がありますね。  
もし高校・大学の講義を受けているのであれば、「メモリ」にデータを保存し、  
メモリが格納されている番地のようなもの（アドレス）が宛先として指定可能である、    
って習ったかもしれません。命令をカウントするには命令そのものを保存しておく必要がありますね。  
（メモリは市販PCとかで8GB,16GBとか言われるくらいなので、今回はめっちゃ大きくて命令は全部保存できるとしましょう。）  
  
・もっと詳しい講義を取っていた方は、CPUがメチャクチャ計算が速い理由として、  
CPUが「レジスタ」と呼ばれるメモリぽいものを持っており、保存できる量は少ないものの  
爆速で計算できる、ということまで知っているかもしれません。  
（レジスタは量↓で速度↑、メモリは量↑で速度↓というイメージです。  
気になる方はトランジスタとキャパシタ、SRAMとDRAMについて調べてみてくださいね。）  
（「１回目」に、「レジスタ３」に入っている3と「レジスタ５」に入っている5を「足し」て、  
結果を「レジスタ７」に入れるとするなら、01:010-001-011-101-111、とかって表せますかね。）  
  
・あぶないあぶない、x=3, y=5にしておいてからx+y=8にしてるなら、3とか5とかの「値そのものを保存する場所」がありませんでした。  
（「１回目」に、「レジスタ３」に入っている3に「5」を「足し」て、  
結果を「レジスタ６」に入れるとするなら、01:010-001-011-101-110、とかって書けそう？  
ってことは、レジスタは2~3個必要で、値そのものは0~1個必要そうですね。）  

・さっきから（カッコ）でCPUぽく作っていましたが、0,1だけで命令を作ってるから、1bitでもズレたらヤバそうすね。  
じゃあ、「命令全体は○○bit」って決めておいたほうが良さそうですね。  
（せっかく010-001-011-101-111とか010-001-011-101-110としたから、この例なら15bitにしておけば良さそう？
1bit左にずらして100-010-111-011-110とかになったら、違う命令になってしまう、、。）  
  
これらをまとめると、  
・命令を管理するものとして「カウントするもの」「メモリの容量」は用意しておいて、
・命令そのものには「全体の長さ」「命令を大きく分類」「似た命令をさらに分類」「値を持っておくレジスタ×2~3個」「値そのもの×0~1個」  
があれば、命令を正しく「分かる」ことができそうですね。  

（もしあなたが、ホントに見落としたもの・不要なものはないんですか？と疑問を持ったようであれば問題なく。  
後でちゃんと伏線回収（という名の予定調和）してるので、ちゃんと必要十分になってますよ。）    
  
# 3.そもそも、電気だけで命令をどう作っている？
作業中
  


# 4.ALUをChiselでつくってみた！  
作業中
　　
### これが動けばOK！！  
  
![これでOK](https://github.com/shinrabansyo/tech-blog/blob/main/Articles/01-CPU%E3%82%92%E3%81%A4%E3%81%8F%E3%82%8D%E3%81%86%EF%BC%88%E3%81%84%E3%81%8D%E3%81%AA%E3%82%8A%EF%BC%81%EF%BC%9F%EF%BC%89/01-02_%E5%8A%A0%E7%AE%97%E5%99%A8%E3%82%92%E3%81%A4%E3%81%8F%E3%82%8B/images/02_UgokebaOK.gif)  
  
とりあえず、サンプルコードをgit cloneしてきて、CPU-2中でtestが動けばOKです。  
できる方はどんな手を使ってもよいので、どうぞ。


### 筆者はこうやりました
  
（参考までに、筆者はWindows11を使っています。　上手くいかない場合はインターネットや友人に相談してみてくださいね。（定期））
  
1. Alu.scalaをChiselで書く  
  
![Adder.scala](https://github.com/shinrabansyo/tech-blog/blob/main/Articles/01-CPU%E3%82%92%E3%81%A4%E3%81%8F%E3%82%8D%E3%81%86%EF%BC%88%E3%81%84%E3%81%8D%E3%81%AA%E3%82%8A%EF%BC%81%EF%BC%9F%EF%BC%89/01-02_%E5%8A%A0%E7%AE%97%E5%99%A8%E3%82%92%E3%81%A4%E3%81%8F%E3%82%8B/images/03_Adder-scala.gif)   
  
・上にも出てきていますが、一応解説しますね。  
```  
package core

import chisel3._
// Javaだと import java.util.* 、  
// Pythonだとfrom module import *みたいな感じですね  
  
// ModuleはChiselの基本的なクラス（IOやBundleなどの便利関数を持ってる）  
class Adder extends Module {  
   // IOは入出力を定義するためのクラス  
   // Bundleは複数の信号をまとめるためのクラス  
   val io = IO(new Bundle {  
      // CPU（今回はFPGA）は0,1を保持しておくもの（トランジスタで作られたフリップフロップ）をいっぱい持ってます  
      // そのうちの8個(とそれぞれにつながる導線＆動線、だからW(idth)型)をaとして割り振る（b, outも同様）、という意味です
      // この8個のフリップフロップのカタマリを、a「レジスタ」と呼んだりします  
      val a        = Input(UInt(8.W))  
      val b        = Input(UInt(8.W))  
      val out      = Output(UInt(8.W))  
  })  
  // 8個の0,1では2の8乗（256）通りの組み合わせがあるので、0-255までの数値を表現できます  
  // なので大きい数を足し合わせると、、？（あとでやります）    
  io.out := io.a + io.b  
}  
```  
  
  
・筆者の個人的ポイント：  
やはり、コードを書けるようになるのではなく（書けるに越したことはないですが）、  
- 今回は「値を保存するもの」を物理的に用意しているのではあって「値」を入れているわけではない
- ソフトウェア記述言語では、「値」が保存されるが、その裏では「値」を保存するために上のやつ↑が自動的に行われている  
というイメージができるようになった方が幸せかもしれません。（私は理解するのに3hかかりました）  
ちなみに、フリップフロップに電気信号を送る際は有名なものだと「0（電圧をかけない）で」「出力1」を表示するとありますが、  
これは裏でいい感じにやってくれてるくれてないとか、、？  
![FlipFlop](https://github.com/shinrabansyo/tech-blog/blob/main/Articles/01-CPU%E3%82%92%E3%81%A4%E3%81%8F%E3%82%8D%E3%81%86%EF%BC%88%E3%81%84%E3%81%8D%E3%81%AA%E3%82%8A%EF%BC%81%EF%BC%9F%EF%BC%89/01-02_%E5%8A%A0%E7%AE%97%E5%99%A8%E3%82%92%E3%81%A4%E3%81%8F%E3%82%8B/images/05.flipflop.png)  
  
  
2. Core.scalaをChiselで書く  
  
![Top.scala](https://github.com/shinrabansyo/tech-blog/blob/main/Articles/01-CPU%E3%82%92%E3%81%A4%E3%81%8F%E3%82%8D%E3%81%86%EF%BC%88%E3%81%84%E3%81%8D%E3%81%AA%E3%82%8A%EF%BC%81%EF%BC%9F%EF%BC%89/01-02_%E5%8A%A0%E7%AE%97%E5%99%A8%E3%82%92%E3%81%A4%E3%81%8F%E3%82%8B/images/04_Top-scala.gif)  

・これも上で出てきていますが、一応解説しますね。  
（インポート部分で何ができるか詳しく知りたい方は、[公式github](https://github.com/chipsalliance/chisel)や
[org.scalatest.flatspec](https://www.scalatest.org/scaladoc/1.8/org/scalatest/FlatSpec.html)などをご確認ください）  
```  
package core  
  
// テストに使用するやつもインポート    
import chisel3._  
import chiseltest._  
import chisel3.iotesters._  
import org.scalatest.flatspec.AnyFlatSpec  
  
// Chiselのテストをするとき、ScalaTestとChiselScalatestTester（ScalaTestと組み合わせてChiselのモジュールをテスト）の機能を使う  
class TopTest extends AnyFlatSpec with ChiselScalatestTester {  
  
   // it must "runs Top" ≒ テストのゴール：Topが最後まで動くこと  
   // test(new Adder) ≒ Adderモジュールのインスタンスをテスト  
   // withAnnotations(Seq(WriteFstAnnotation)) ≒ FST（Fast Signal Trace）ファイルに波形データを書き出すためのアノテーションを追加  
   it must "runs Top" in { test(new Adder).withAnnotations(Seq(WriteFstAnnotation)) { c =>  

      // pokeで入力を与える、今回なら8個のフリップフロップ（のレジスタa）の内、下位2ビット分に電気信号を与えて1の状態にする（00000011 （2進数） ≒ 3（10進数））
      // peek（今は使ってませんが）で現在の状態を確認、確認するだけで間違いを指摘するわけではない  
      // expectで出力を検証、こっちは確認して間違ったら指摘してくれる

      // c.clock.step(1) で1クロック進める、poke, peek, expectは時間が止まった状態で行われるので、stepさせて（時間を進めて）初めてシミュレーションが進む  
      // aにpoke、bにpokeを（1クロック進めて）反映させるイメージ  
        
      // 通常のテスト  
      c.io.a.poke(3.U)  
      c.io.b.poke(5.U)  
      c.clock.step(1)  
      c.io.out.expect(8.U)  
      // オーバーフローしたときのテスト  
      c.io.a.poke(250.U)  
      c.io.b.poke(10.U)  
      c.clock.step(1)  
      c.io.out.expect(4.U)  
   } }  
}  
  
```  
  
・筆者の個人的ポイント：シミュレーション特有の時間管理は要チェックですね、、。  
オーバーフロー後に4が入るのは、250（11111001）＋ 10（00001010）＝ （260（100000100）だけど8bitで表示できないので）4（00000100）というイメージです。 
ちなみにずっと「U」int（符号なし整数）でやってるのは、 int（符号付き整数）だと計算結果のバグ等イロイロ面倒だからです、、。  
  
3. Top.scala（Adder.scalaをテストするやつ）をChiselで書く  
正しく動くと上と同じ、全部「passed」になります。  
![sbt test（あってるとき）](https://github.com/shinrabansyo/tech-blog/blob/main/Articles/01-CPU%E3%82%92%E3%81%A4%E3%81%8F%E3%82%8D%E3%81%86%EF%BC%88%E3%81%84%E3%81%8D%E3%81%AA%E3%82%8A%EF%BC%81%EF%BC%9F%EF%BC%89/01-02_%E5%8A%A0%E7%AE%97%E5%99%A8%E3%82%92%E3%81%A4%E3%81%8F%E3%82%8B/images/02_UgokebaOK.gif)  
250 + 10 = 「4」を「2」にしてみるとこんな感じ。ちゃんと「違う！！」って言ってくれます。  
![sbt test（違うとき）](https://github.com/shinrabansyo/tech-blog/blob/main/Articles/01-CPU%E3%82%92%E3%81%A4%E3%81%8F%E3%82%8D%E3%81%86%EF%BC%88%E3%81%84%E3%81%8D%E3%81%AA%E3%82%8A%EF%BC%81%EF%BC%9F%EF%BC%89/01-02_%E5%8A%A0%E7%AE%97%E5%99%A8%E3%82%92%E3%81%A4%E3%81%8F%E3%82%8B/images/06.TestNG.gif)  
  
4. 実行（sbt test）したらこんな感じ  
正しく動くと上と同じ、全部「passed」になります。  
![sbt test（あってるとき）](https://github.com/shinrabansyo/tech-blog/blob/main/Articles/01-CPU%E3%82%92%E3%81%A4%E3%81%8F%E3%82%8D%E3%81%86%EF%BC%88%E3%81%84%E3%81%8D%E3%81%AA%E3%82%8A%EF%BC%81%EF%BC%9F%EF%BC%89/01-02_%E5%8A%A0%E7%AE%97%E5%99%A8%E3%82%92%E3%81%A4%E3%81%8F%E3%82%8B/images/02_UgokebaOK.gif)  
250 + 10 = 「4」を「2」にしてみるとこんな感じ。ちゃんと「違う！！」って言ってくれます。  
![sbt test（違うとき）](https://github.com/shinrabansyo/tech-blog/blob/main/Articles/01-CPU%E3%82%92%E3%81%A4%E3%81%8F%E3%82%8D%E3%81%86%EF%BC%88%E3%81%84%E3%81%8D%E3%81%AA%E3%82%8A%EF%BC%81%EF%BC%9F%EF%BC%89/01-02_%E5%8A%A0%E7%AE%97%E5%99%A8%E3%82%92%E3%81%A4%E3%81%8F%E3%82%8B/images/06.TestNG.gif)  
  
  
　　
----------------  
**・足し算できましたでしょうか？**  
この記事を見てもできなかった・内容がおかしい等あれば、コメントやX（Twitter）で教えていただけると嬉しいです！  
  
次回は、CPUのALU部分の続き、メモリやプログラムカウンタを用意していきます！  
  
担当：Astalisks  
      
次の記事は[制作中、しばらくお待ちください！](←リンク貼る)  
