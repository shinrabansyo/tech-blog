おはこんばんにちは！森羅万象プロジェクトです！  
（前回から8カ月ほどたちましてゴメンナサイ、、。）  
前回は[01-03_命令をやりとりできる](https://github.com/shinrabansyo/tech-blog/blob/main/Articles/01-CPU%E3%82%92%E3%81%A4%E3%81%8F%E3%82%8D%E3%81%86%EF%BC%88%E3%81%84%E3%81%8D%E3%81%AA%E3%82%8A%EF%BC%81%EF%BC%9F%EF%BC%89/01-03_%E5%91%BD%E4%BB%A4%E3%82%92%E9%80%81%E3%82%8B%E3%83%BB%E5%8F%97%E3%81%91%E5%8F%96%E3%82%8B/01-03_%E5%91%BD%E4%BB%A4%E3%82%92%E9%80%81%E3%82%8B%E3%83%BB%E5%8F%97%E3%81%91%E5%8F%96%E3%82%8B.md)ようにしたので、  
  
今回は**他の命令を追加**していきたいと思います。  

（定期宣伝）  
ちなみにこの記事は、   
**CPUを作ったことのなかった人による、**  
**CPUを作ったことのない人のための記事**  
ですので、CPU入門・初心者の筆者と一緒に  
勉強していただけたらと思っています！！  
  
（アドベントカレンダーなので宣伝）

// 前回-> add/addi 命令の実装
// この記事-> いろいろな命令の追加


今回は、  
CPUに必要な命令（の一部）を考えていきます。  
CPU作成部分の醍醐味というか、目玉な気もしますね！  
「CPUに送る・CPUが認識できる命令」について、  
**1.CPUに必要な命令１：演算を行う命令**  <- 実装完了
  **1.1.ALUを充実させてみた！**
**2.CPUに必要な命令２：メモリにアクセスする命令**  <- まだ
**3.CPUに必要な命令３：分岐を表す命令**  <- まだ
**4.プログラム書いてみた** <- アセンブラある前提
  **4.1アセンブリの記法説明**
  **4.2アセンブラの利用**
  **4.3実行の様子**
に分けて説明していきます。

# 1.CPUに必要な命令１：演算を行う命令 
（はじめに、この記事で追加する命令ですが、元の開発に合わせて  
増えたり減ったりするかもしれません！  
また、市販のCPUがこれらの命令だけで動いているとは限りません！！）  
前回の記事では、CPU（のALUっていう演算をするもの）に  
足し算の命令を追加しました。  
一度、その足し算命令について確認してみましょう。  

- add命令  
  - 2つのレジスタの値を足して、結果を別のレジスタに格納する。  
  - 例：`add r1, r2, r3`  
    - r2の値とr3の値を足して、r1に格納する。
  
- addi命令  
  - レジスタの値に即値を足して、結果を別のレジスタに格納する。  
  - 例：`addi r1, r2, 3`  
    - r2の値に3を足して、r1に格納する。
  
足し算があれば、引き算もありますね。似たような感じでつくってしまいましょう。  
  
- sub命令  
  - 2つのレジスタの値を引いて、結果を別のレジスタに格納する。  
  - 例：`sub r1, r2, r3`  
    - r2の値からr3の値を引いて、r1に格納する。

- subi命令  
  - レジスタの値から即値を引いて、結果を別のレジスタに格納する。  
  - 例：`subi r1, r2, 3`  
    - r2の値から3を引いて、r1に格納する。
  

and, or, xor, srl, sra, sll
andi, ori, xori, srli, srai, slli...





**2.CPUに必要な命令２：メモリにアクセスする命令**  
データを足し引き出来るなら、そのデータを保存したり読み出したり  
できるようにしたい気もします。  
（今回はadd, addi命令と同様、「レジスタの値」に「即値」を足して、  
「そのレジスタから値を読み込んでくる」or「レジスタに値を書き込む」
形とします。）  

- lw命令  
  - レジスタの値と即値を足し合わせたアドレスから32bitのデータを読み込み、  
  結果をレジスタに格納する。  
    - 32bitなのは入る即値（imm）が最大32bitだから。
  - 例：`lw r1, r2, 3`  
    - r2の値に3を足したアドレスから32bitのデータを読み込み、r1に格納する。

- sw命令  
  - レジスタの値と即値を足し合わせたアドレスにレジスタの値を書き込む。  
  - 例：`sw r1, r2, 3`  
    - r2の値に3を足したアドレスにr1の値を書き込む。


レジスタだけだと、レジスタ32個分のデータまでしか扱えません。  
レジスタが32個しかない->32種類のデータしか扱うことができない
-> それ以上のデータを扱うにはレジスタの値（中身）をどこか（＝メモリ）に保存する必要がある
（val regfile = RegInit(VecInit(Seq.tabulate(32) { i => 0.U(32.W) }))より）  
lw, sw,...
メモリが欲しくなる理由→量が足りないではなく扱えるデータ少ないから
SDカード・・spiで送る・R1response,,,・などを固定数のレジスタだとやりくりする必要がある
レジスタのデータを一時的に保管する場所としてメモリが欲しくなる


**3.CPUに必要な命令３：分岐を表す命令**  
プログラミングしたことのある人なら、if文やwhile文など  
触れたことがあるかもしれません。  
if文とかでよくあるのが、「iが○○（一定の数値）を超えたらやめる」といった  
「2値を比較する動作」です。    
CPUは0か1でしかものを表せないですが、  
「条件を満たせば1, 満たさないなら0」くらいなら操作できますね！  
  
AがB「以上、以下、未満」であったり、AとBが「等しい・等しくないであったり」を  
何命令で網羅できるでしょうか、、？  
網羅するだけであれば、2つの命令を実装すれば良いとは思いますが、、（  
１：AとBが等しいなら1, 等しくないなら0   
２：AがB以下なら1, 当てはまらないなら0
未満にするなら、Bに-1するなど対応すれば良い）  
ただ、○○なので、  
今回は「等しいとき」「等しくないとき」「以下」「未満」の  
4つを実装することにします。  
加えて、「レジスタ」分だけ


ble, bne, beq, blt, jal...


**4.ALUを充実させてみた！**
コードの説明

実装の種類はR形式、I形式、など3種類
add系、lwsw系、ble系
演算、メモリアクセス、分岐系


